% DEMO: lambda functions
%
% This demo shows how to set up and use lambda (anonymous) functions.
% Matlab also refers to these as function handles:
%
% You can also use Matlab's internal documentation to learn more about
% these functions by typing the following command:
%
% >> help function_handle
% 
%      FUNHANDLE = @FUNCTION_NAME returns a handle to the named function,
%      FUNCTION_NAME. A function handle is a MATLAB value that provides a
%      means of calling a function indirectly. You can pass function
%      handles in calls to other functions (which are often called function
%      functions). You can also store function handles in data structures for
%      later use (for example, as Handle Graphics callbacks). A function
%      handle is one of the standard MATLAB data types. Its class is
%      'function_handle'.
%  
%      FUNHANDLE = @(ARGLIST)EXPRESSION constructs an anonymous function and
%      returns a handle to that function. The body of the function, to the 
%      right of the parentheses, is a single MATLAB expression. ARGLIST is a
%      comma-separated list of input arguments. Execute the function by
%      calling it by means of the returned function handle, FUNHANDLE. For
%      more information on anonymous functions, see "Types of Functions" in
%      the MATLAB Programming documentation.
%  
%      To call the function referred to by a function handle value, use ordinary
%      parenthesis notation.  That is, specify the function handle variable
%      followed by a comma-separated list of input arguments enclosed in
%      parentheses. For example, HANDLE(ARG1, ARG2, ...). To call a
%      function_handle with no arguments, use empty parenthesis, e.g.,
%      HANDLE().
%  
%      Example 2, below, shows how to make a call using a function handle
%      that has been passed as an argument.
%  
%      When you evaluate a function handle to a subfunction or private
%      function, that subfunction or private function is always executed when
%      the function handle is called.  When you evaluate a function handle to
%      a built-in or ordinary function, an appropriate method may be selected
%      instead of the built-in or ordinary function.
%  
%      With one exception, function handles can be manipulated and operated on in
%      the same manner as other MATLAB values, including assignment to variables
%      and inclusion in cells and structs.  The exception is that you cannot
%      construct a function_handle array.  The reason is that the parenthesis
%      notation for values of this class is used to call a function, not to
%      index an array.  To achieve the effect of an array of function handles,
%      use cells, e.g., write "A = {@sin, @cos}" rather than "A = [@sin, @cos]".
%      Of course, you need to index A with braces: "A{i}".
%  
%      Function handles enable you to:
%  
%        Pass a function reference to another function.
%        Reduce the number of files that define your functions.
%        Improve performance in repeated operations.
%        Ensure reliability when evaluating functions.
%  
%      Example 1 - Construct a handle, f, to the HUMPS function, and pass this 
%      handle to FMINBND. (MATLAB maps a specific implementation of the HUMPS
%      function to the handle f at the time the handle is created, and not at
%      the time f is called.)
%  
%          f = @humps;
%          x = fminbnd(f,1,2);
%  
%      Example 2 - Call a function by means of the function handle, h, that
%      was passed as an argument.
%  
%      function trigPlot(h, val)
%      if isa(h, 'function_handle')   % Verify that h is a function handle.
%         A = h(val);                 % Call the function mapped to handle h.
%         plot(A)                     % Plot the resulting data.
%         end
%  
%      Call the function, passing the handle generated by @cos:
%  
%         trigPlot(@cos, -pi:0.01:pi)
%  
%      See also func2str, str2func, functions.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clc; clear;

%% Set up a figure to use for plotting
figure(10001); clf; hold on;
title('Lambda function demo');
xlabel('t')
ylabel('function value')

%% Lambda function basics:
funOne = @(x)( 0.1 * x.^2 );
t = linspace(0, 2*pi,100);
plot(t, funOne(t), 'g-', 'LineWidth', 2);

%% Lambda function as an alias:
% call a function by a new name:
myCos = @cos;
y = myCos(t);
plot(t, y, 'b--', 'LineWidth', 3);

%% Lambda function with arguments:
% specify arguments for the lambda function
myPlot = @(t,x)( plot(t,x) );
myPlot(t, 2*y);
% myPlot(t, y, 'b-');  %  <--- error: myPlot() only accepts two arguments

%% Lambda function with parameter capture:
% specify parameters from the local scope
plotWithRedLine = @(t,x)( plot(t, x, 'r-', 'LineWidth', 2) );
plotWithRedLine(t + 2, 1.3*myCos(1.1 * t));

%% Lambda function with dropped arguments:
% you can drop unused parameters:
funTwo = @(x1, x2)( sin(x2) );
fprintf('funTwo(0, pi) = %6.6f\n', funTwo(0, pi));

%% Lambda function passed to another function:
% lambda functions are often used for solvers, such as fzero
cubicFun = @(t)( (t + 1) .* (t - 1) .* (t - 3) );
cubicSoln = fzero(cubicFun, 0.0);
fprintf('cubicSoln = %6.6f\n', cubicSoln);

%% Lambda function with local parameters, passed to function:
b = 3.5;
c = -1.2;
funThree = @(t)( sin(t - b) + (t - c) .*(t - b) );
solnThree = fzero(funThree, 0);
fprintf('solnThree = %6.6f\n', solnThree);

%% Lambda function wrapper for sub-function
param.width = 2;
param.height = 3;
funFour = @(t)( myLocalFun(t, param) );
solnFour = fzero(funFour, 0);
fprintf('solnFour = %6.6f\n', solnFour);

%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~%

function z = myLocalFun(t, param)
% z = myLocalFun(t, param)
%
% A simple function that is used for testing.

width = param.width;
height = param.height;

z = t * width + t.^2 * height - 1;

end